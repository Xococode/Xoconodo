<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xoconodo - Editor de Diagramas v1.5.1 (Fix & Features)</title>
    <link rel="stylesheet" href="https://unpkg.com/reactflow@latest/dist/style.css" />
    <style>
        /* ... (CSS sin cambios desde la v1.5.0) ... */
        :root {
            --primary-color: #FF0066;
            --secondary-color: #333333;
            --background-color: #ffffff; /* Fondo general de la página */
            /* --dots-color: #e2e2e2; Antiguo color de puntos */
            --dots-color: #474747;   /* Nuevo color de puntos más visible */ 
            /* O prueba con #a0a0a0 o #999999 para aún más contraste */
            --node-border-color-default: #FF0066;
            --node-background-color-default: #ffffff;
            --button-color: #FF0066;
            --button-text-color: white;
            --button-hover-color: #e6005c;
            --edge-label-bg: rgba(255, 255, 255, 0.85);
            --edge-label-color: #333;
        }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; background-color: var(--background-color); height: 100vh; overflow: hidden; }
        .flow-app-container { display: flex; flex-direction: column; height: 100vh; }
        .main-content { display: flex; flex-grow: 1; position: relative; overflow: hidden; }
        #reactflow-root { flex-grow: 1; height: 100%; position: relative; }
        .logo-panel { padding: 15px; font-weight: bold; font-size: 24px; color: var(--primary-color); }
        .header-actions-panel { padding: 10px; display: flex; gap: 8px; }
        .header-actions-panel .sidebar-button { background-color: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .header-actions-panel .sidebar-button:hover { background-color: #f0f0f0; }
        .header-actions-panel .sidebar-button:disabled { background-color: #e9e9e9; opacity: 0.6; }
        .left-sidebar-panel { display: flex; flex-direction: column; gap: 8px; padding: 12px; background-color: rgba(255, 255, 255, 0.95); border-radius: 0 8px 8px 0; box-shadow: 2px 0 5px rgba(0,0,0,0.05); z-index: 25; }
        .tools-toolbar-panel { background-color: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; flex-wrap: wrap; padding: 8px; gap: 6px; z-index: 25; max-width: fit-content; }
        .sidebar-button { display: flex; align-items: center; padding: 8px 12px; border-radius: 4px; background-color: white; border: 1px solid #eaeaea; cursor: pointer; font-size: 14px; color: var(--secondary-color); transition: all 0.2s; gap: 6px; white-space: nowrap; }
        .sidebar-button svg { stroke: currentColor; width: 14px; height: 14px; }
        .sidebar-button:hover { background-color: #f9f9f9; border-color: #ddd; }
        .sidebar-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #f0f0f0; border-color: #eaeaea;}
        .sidebar-button.primary { background-color: var(--button-color); color: var(--button-text-color); border: none; }
        .sidebar-button.primary:hover { background-color: var(--button-hover-color); }
        .sidebar-button.primary:disabled { background-color: #ff80b3; }
        .sidebar-button.primary svg { stroke: var(--button-text-color); }
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; margin-right: 8px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(20px); }
        .auto-layout { display: flex; align-items: center; }
        .tool-button { height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 4px; cursor: pointer; transition: all 0.2s; border: 1px solid transparent; padding: 0 8px; font-size: 12px; background-color: #f0f0f0; }
        .tool-button:hover { background-color: #e0e0e0; }
        .tool-button.selected { background-color: #c0c0c0; border-color: var(--primary-color); }
        .tool-button:disabled { opacity: 0.5; cursor: not-allowed; }
        .tool-icon { width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; border: 1.5px solid #333; }
        .tool-icon.rect { border-radius: 0; } .tool-icon.circle { border-radius: 50%; } .tool-icon.diamond { transform: rotate(45deg); }
        .tool-icon.trash { border: none; color: #FF0066; } .tool-icon.trash svg { stroke: #FF0066; }
        .tool-color { width: 24px; height: 24px; border-radius: 4px; border: 1px solid #eaeaea; }
        .tools-toolbar-divider { width: 1px; background-color: #eaeaea; margin: 0 4px;}
        .toolbar-group { display: flex; gap: 4px; align-items: center; padding: 2px 4px; border: 1px solid #eee; border-radius: 4px;}
        .toolbar-group-label { font-size: 10px; color: #777; margin-right: 4px; white-space: nowrap; }
        .base-node { padding: 10px; border-radius: 6px; min-width: 150px; min-height: 40px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: 500; font-size: 13px; text-align: center; position: relative; box-shadow: 0 1px 3px rgba(0,0,0,0.1); cursor: grab; white-space: pre-line; border: 2px solid var(--node-border-color-default); background-color: var(--node-background-color-default); }
        .react-flow__node-selected .base-node { box-shadow: 0 0 0 2px var(--primary-color), 0 4px 12px rgba(0,0,0,0.2); }
        .custom-node.rect { border-radius: 6px; } .custom-node.circle { border-radius: 50%; width: 80px; height: 80px; padding: 5px; } .custom-node.diamond { width: 100px; height: 100px; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); padding: 15px; }
        .node-label-input, .node-config-input { width: 90%; padding: 4px 6px; border: 1px solid var(--primary-color); border-radius: 3px; font-family: inherit; font-size: inherit; text-align: center; background-color: rgba(255, 255, 255, 0.9); box-sizing: border-box; resize: none; overflow: hidden; margin-top: 5px; }
        .node-label-input:focus, .node-config-input:focus { outline: none; box-shadow: 0 0 0 2px rgba(var(--primary-color), 0.5); }
        .node-handle { width: 10px; height: 10px; border: 2px solid white; box-shadow: 0 0 0 1px var(--primary-color); border-radius: 50%; z-index: 10; background-color: var(--primary-color); opacity: 0.7; }
        .base-node:hover .node-handle, .react-flow__node-selected .node-handle { opacity: 1; }
        .react-flow__handle-connecting { background-color: #fff !important; border-color: var(--primary-color) !important; }
        .react-flow__handle-valid { background-color: #55dd99 !important; }
        .node-add-button { width: 20px; height: 20px; border-radius: 50%; background-color: var(--primary-color); color: white; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; cursor: pointer; position: absolute; left: 50%; bottom: -25px; z-index: 10; box-shadow: 0 1px 3px rgba(0,0,0,0.2); opacity: 0; transition: opacity 0.2s, transform 0.2s; transform: translateX(-50%);}
        .base-node:hover .node-add-button, .react-flow__node-selected .base-node .node-add-button { opacity: 1; transform: translateX(-50%) translateY(3px); }
        .image-node-content { background-color: transparent; border: none; box-shadow: none; padding: 0; position: relative; overflow: visible; cursor: grab; }
        .image-node-content img { display: block; width: 100%; height: 100%; object-fit: contain; user-select: none; pointer-events: none; }
        .react-flow__node-selected .image-node-content { box-shadow: 0 0 0 2px var(--primary-color); }
        .resize-handle { position: absolute; width: 10px; height: 10px; background-color: var(--primary-color); border: 1px solid white; border-radius: 50%; cursor: nwse-resize; right: -5px; bottom: -5px; z-index: 20; opacity: 0; }
        .react-flow__node-selected .image-node-content .resize-handle { opacity: 1; }
        .functional-node-content { padding: 8px; font-size: 12px; color: #555; max-width: 200px; word-break: break-all; }
        .functional-node-button { background-color: var(--primary-color); color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-top: 8px; }
        .functional-node-button:hover { background-color: var(--button-hover-color); }
        .react-flow__minimap { background-color: rgba(240, 240, 240, 0.85); border-radius: 4px; box-shadow: 0 1px 4px rgba(0,0,0,0.1); z-index: 20; }
        .react-flow__minimap-mask { fill: rgba(255, 0, 102, 0.15); }
        .react-flow__minimap-node { fill: var(--secondary-color); stroke: none; } .react-flow__minimap-node.selected { fill: var(--primary-color); }
        .react-flow__attribution { display: none !important; }
        .custom-attribution { position: absolute; bottom: 5px; right: 5px; font-size: 10px; background: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 3px; z-index: 20; }
        .custom-attribution a { color: var(--primary-color); text-decoration: none; }
        .custom-attribution a:hover { text-decoration: underline; }
        .edge-label-input { padding: 2px 5px; font-size: 10px; border: 1px solid var(--primary-color); border-radius: 3px; background-color: var(--edge-label-bg); color: var(--edge-label-color); text-align: center; }
        @keyframes dashdraw { to { stroke-dashoffset: -20; } }
        .react-flow__controls { z-index: 25 !important; }
        .context-menu { position: absolute; background: white; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.1); border-radius: 4px; padding: 5px 0; z-index: 1000; min-width: 150px; }
        .context-menu button { display: flex; align-items: center; gap: 8px; background: none; border: none; padding: 8px 12px; width: 100%; text-align: left; cursor: pointer; font-size: 14px; }
        .context-menu button:hover { background-color: #f0f0f0; }
        .context-menu button svg { width: 16px; height: 16px; stroke: currentColor; }
        .node-lock-icon { position: absolute; top: -6px; right: -6px; background: rgba(255,255,255,0.8); border-radius: 50%; padding: 2px; display: flex; align-items: center; justify-content: center; }
        .node-lock-icon svg { width: 12px; height: 12px; stroke: var(--secondary-color); }
    </style>
</head>
<body>
    <div id="app-container">Cargando Editor Xoconodo...</div>

    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/reactflow@latest/dist/umd/index.js"></script>

    <script>
        if (!React || !ReactDOM || !ReactFlow) {
            document.getElementById('app-container').innerText = "Error crítico: No se pudieron cargar las librerías de React o ReactFlow...";
        } else {
            const {
                ReactFlowProvider, Background, Controls: RFControls, Handle, Panel, MiniMap, EdgeLabelRenderer,
                useNodesState, useEdgesState, useReactFlow, addEdge,
                applyNodeChanges, applyEdgeChanges, getConnectedEdges, getBezierPath,
                MarkerType, Position
            } = ReactFlow;
            const ReactFlowComponent = ReactFlow.default;

            let nodeIdCounter = 0;

            const createNewNode = (id, position, data = {}) => ({ id: id.toString(), type: 'customNode', position, data: { label: data.label || `Node ${id}`, shape: data.shape || 'rect', color: data.color || '#ffffff', borderColor: data.borderColor || '#FF0066', borderStyle: data.borderStyle || 'solid', outputValue: data.label || `Node ${id}`, locked: false } });
            const createNewImageNode = (id, position, data = {}) => ({ id: id.toString(), type: 'imageNode', position, data: { src: data.src || 'https://via.placeholder.com/150', width: data.width || 150, height: data.height || 100, rotation: data.rotation || 0, originalWidth: data.originalWidth || 150, originalHeight: data.originalHeight || 100, locked: false }, style: { width: data.width || 150, height: data.height || 100 } });
            const createConcatenateNode = (id, position, data = {}) => ({ id: id.toString(), type: 'concatenateNode', position, data: { label: 'Concatenar', inputs: {input_0: '', input_1: ''}, outputValue: '', separator: data.separator || '', numInputs: 2, locked: false, ...data } });
            const createResultNode = (id, position, data = {}) => ({ id: id.toString(), type: 'resultNode', position, data: { label: 'Resultado', inputValue: '', locked: false, ...data } });
            const createDownloadNode = (id, position, data = {}) => ({ id: id.toString(), type: 'downloadNode', position, data: { label: 'Descargar', inputValue: '', filename: data.filename || 'datos.txt', locked: false, ...data } });
            const createCapitalizeNode = (id, position, data = {}) => ({ id: id.toString(), type: 'capitalizeNode', position, data: { label: 'Capitalizar', inputValue: '', outputValue: '', locked: false, ...data } });
            const createUppercaseNode = (id, position, data = {}) => ({ id: id.toString(), type: 'uppercaseNode', position, data: { label: 'Mayúsculas', inputValue: '', outputValue: '', locked: false, ...data } });
            const createLowercaseNode = (id, position, data = {}) => ({ id: id.toString(), type: 'lowercaseNode', position, data: { label: 'Minúsculas', inputValue: '', outputValue: '', locked: false, ...data } });

            let initialNodes = [createNewNode(++nodeIdCounter, { x: window.innerWidth/2 - 75, y: window.innerHeight/3 - 50 }, {label: 'Nodo Inicial'})];
            let initialEdges = [];
            let initialViewport = { x: 0, y: 0, zoom: 1 };

            const urlParams = new URLSearchParams(window.location.search);
            const flowParam = urlParams.get('flow');
            if (flowParam) {
                try {
                    const decodedFlow = JSON.parse(atob(decodeURIComponent(flowParam)));
                    if (decodedFlow.nodes && decodedFlow.edges) {
                        initialNodes = decodedFlow.nodes;
                        initialEdges = decodedFlow.edges;
                        initialViewport = decodedFlow.viewport || initialViewport;
                        nodeIdCounter = (initialNodes || []).reduce((maxId, node) => Math.max(maxId, parseInt(node.id.replace(/[^0-9]/g, '')) || 0), 0);
                         nodeIdCounter = Math.max(nodeIdCounter, (initialEdges || []).reduce((maxId, edge) => Math.max(maxId, parseInt(edge.id.replace(/[^0-9]/g, '')) || 0), 0));
                    }
                } catch (e) { console.error("Error al cargar el flujo desde la URL:", e); }
            }
            const lockIconSVG = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('rect',{x:"3",y:"11",width:"18",height:"11",rx:"2",ry:"2"}), React.createElement('path',{d:"M7 11V7a5 5 0 0110 0v4"}));
            const unlockIconSVG = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('rect',{x:"3",y:"11",width:"18",height:"11",rx:"2",ry:"2"}), React.createElement('path',{d:"M7 11V7a5 5 0 019.9-1M15 11V7a3 3 0 00-6 0"}));

            const NodeWrapper = ({ children, data }) => { return React.createElement(React.Fragment, null, children, data.locked && React.createElement('div', { className: 'node-lock-icon', title: 'Nodo bloqueado' }, lockIconSVG)); };
            const CustomNode = ({ id, data, selected, isConnectable, onLabelChange, recordAction }) => { const nodeContent = () => { const { getNode, setNodesDraggable: setNodeDraggableReactFlow } = useReactFlow(); const [isEditing, setIsEditing] = React.useState(false); const [labelText, setLabelText] = React.useState(data.label); const [originalLabelOnEdit, setOriginalLabelOnEdit] = React.useState(''); const inputRef = React.useRef(null); React.useEffect(() => { setLabelText(data.label); }, [data.label]); const handleDoubleClick = React.useCallback(() => { setOriginalLabelOnEdit(data.label); setIsEditing(true); if (!data.locked) setNodeDraggableReactFlow(false); }, [data.label, data.locked, setNodeDraggableReactFlow]); const finishEditing = React.useCallback((shouldRecord = false) => { setIsEditing(false); if (!data.locked) setNodeDraggableReactFlow(true); if (shouldRecord && typeof recordAction === 'function') recordAction(); }, [data.locked, setNodeDraggableReactFlow, recordAction]); const handleSaveText = React.useCallback(() => { let finalLabel = labelText.trim(); let recorded = false; if (finalLabel === '') { finalLabel = originalLabelOnEdit; setLabelText(originalLabelOnEdit); } if (data.label !== finalLabel) { onLabelChange(id, finalLabel); finishEditing(true); recorded = true; } if(!recorded) finishEditing(false); }, [id, labelText, data.label, originalLabelOnEdit, onLabelChange, finishEditing]); const handleChange = (event) => { const newText = event.target.value; setLabelText(newText); onLabelChange(id, newText); }; const handleKeyDown = (event) => { if (event.key === 'Escape') { setLabelText(originalLabelOnEdit); onLabelChange(id, originalLabelOnEdit); finishEditing(false); } else if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); handleSaveText(); } }; React.useEffect(() => { if (isEditing && inputRef.current) { inputRef.current.focus(); inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length); } }, [isEditing]); const handleAddNodeBelow = React.useCallback(() => { const sourceNode = getNode(id); if (!sourceNode || !window.onAddNodeAndEdgeFromCustomNode) return; nodeIdCounter++; const newNodeId = nodeIdCounter.toString(); const newNodeData = { label: `Node ${newNodeId}`, shape: data.shape, color: data.color, borderColor: data.borderColor, borderStyle: data.borderStyle }; const newNode = createNewNode(newNodeId, { x: sourceNode.position.x, y: sourceNode.position.y + (sourceNode.height || 80) + 60 }, newNodeData); const newEdge = { id: `e-${id}-${newNodeId}`, source: id, sourceHandle: 'bottom-source', target: newNodeId, targetHandle: 'top-target', type: 'customEdge', label: '', data: { lineStyle: window.getSelectedEdgeLineStyle ? window.getSelectedEdgeLineStyle() : 'solid' }, style: { stroke: data.borderColor || '#FF0066', strokeWidth: 2 }, markerEnd: { type: MarkerType.ArrowClosed, color: data.borderColor || '#FF0066' } }; window.onAddNodeAndEdgeFromCustomNode(newNode, newEdge); }, [id, data, getNode]); const nodeStyle = { background: data.color, borderColor: data.borderColor, borderStyle: data.borderStyle, borderWidth: data.borderStyle === 'none' ? 0 : '2px' }; if (data.shape === 'circle') { Object.assign(nodeStyle, { width: '80px', height: '80px' }); } if (data.shape === 'diamond') { Object.assign(nodeStyle, { width: '100px', height: '100px' }); } const classNames = ['base-node custom-node', data.shape || 'rect'].join(' '); const textareaRows = labelText.split('\n').length || 1; const handles = [ { id: 'top-target', type: 'target', position: Position.Top }, { id: 'bottom-source', type: 'source', position: Position.Bottom }, { id: 'left-target', type: 'target', position: Position.Left },  { id: 'right-source', type: 'source', position: Position.Right }, ]; return React.createElement('div', { className: classNames, style: nodeStyle, onDoubleClick: handleDoubleClick }, isEditing ? React.createElement('textarea', { ref: inputRef, value: labelText, onChange: handleChange, onKeyDown: handleKeyDown, onBlur: handleSaveText, className: 'node-label-input', onClick: (e) => e.stopPropagation(), rows: textareaRows, style: { width: '90%', resize: 'none' }}) : data.label, handles.map(h => React.createElement(Handle, { key: h.id, id: h.id, type: h.type, position: h.position, className: 'node-handle', style: {background: data.borderColor}, isConnectable: isConnectable && !isEditing })), !isEditing && React.createElement('div', { className: 'node-add-button', onClick: handleAddNodeBelow, title: "Añadir nodo debajo" }, '+') ); }; return React.createElement(NodeWrapper, { data: data }, nodeContent()); };
            const ImageNode = ({ id, data, selected }) => { const { setNodes, getNode } = useReactFlow(); const nodeRef = React.useRef(null); const [isResizing, setIsResizing] = React.useState(false); const [initialResizeState, setInitialResizeState] = React.useState(null); const onResizeStart = React.useCallback((event) => { event.preventDefault(); event.stopPropagation(); const node = getNode(id); setIsResizing(true); setInitialResizeState({ mouseX: event.clientX, mouseY: event.clientY, width: node.data.width, height: node.data.height, aspectRatio: node.data.originalWidth / node.data.originalHeight }); }, [id, getNode]); const onResize = React.useCallback((event) => { if (!isResizing || !initialResizeState) return; const dx = event.clientX - initialResizeState.mouseX; let newWidth = initialResizeState.width + dx; let newHeight = newWidth / initialResizeState.aspectRatio; newWidth = Math.max(20, newWidth); newHeight = Math.max(20 / initialResizeState.aspectRatio, newHeight); setNodes(nds => nds.map(n => (n.id === id) ? { ...n, data: { ...n.data, width: newWidth, height: newHeight }, style: { ...n.style, width: newWidth, height: newHeight } } : n)); }, [isResizing, initialResizeState, id, setNodes]); const onResizeEnd = React.useCallback(() => { setIsResizing(false); setInitialResizeState(null); const node = getNode(id); setNodes(nds => nds.map(n => (n.id === id) ? { ...n, width: n.data.width, height: n.data.height } : n)); if(window.recordAction) window.recordAction(); }, [id, setNodes, getNode]); React.useEffect(() => { if (isResizing) { document.addEventListener('mousemove', onResize); document.addEventListener('mouseup', onResizeEnd); } else { document.removeEventListener('mousemove', onResize); document.removeEventListener('mouseup', onResizeEnd); } return () => { document.removeEventListener('mousemove', onResize); document.removeEventListener('mouseup', onResizeEnd); }; }, [isResizing, onResize, onResizeEnd]); const internalDivStyle = { width: data.width, height: data.height, transform: `rotate(${data.rotation || 0}deg)`}; return React.createElement('div', { ref: nodeRef, className: 'image-node-content', style: internalDivStyle }, React.createElement('img', { src: data.src, alt: 'Image node', draggable: false }), selected && React.createElement('div', { className: 'resize-handle', onMouseDown: onResizeStart }) ); };
            const ConcatenateNodeComponent = ({ id, data, isConnectable }) => { const { setNodes, setNodesDraggable } = useReactFlow(); const [isEditing, setIsEditing] = React.useState(false); const [separator, setSeparator] = React.useState(data.separator || ''); const inputRef = React.useRef(null); const handleDoubleClick = () => { setIsEditing(true); if(!data.locked) setNodesDraggable(false); }; const handleSaveConfig = () => { let changed = data.separator !== separator; setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, separator: separator } } : n)); setIsEditing(false); if(!data.locked) setNodesDraggable(true); if(changed && window.recordAction) window.recordAction(); }; const handleChange = (e) => setSeparator(e.target.value); const handleKeyDown = (e) => { if (e.key === 'Escape') { setSeparator(data.separator || ''); setIsEditing(false); if(!data.locked) setNodesDraggable(true); } else if (e.key === 'Enter') { handleSaveConfig(); }}; React.useEffect(() => { if (isEditing && inputRef.current) { inputRef.current.focus(); inputRef.current.select(); }}, [isEditing]); const inputHandles = []; for (let i = 0; i < (data.numInputs || 2); i++) { inputHandles.push(React.createElement(Handle, { key: `input_${i}`, type: "target", position: Position.Left, id: `input_${i}`, style: { top: `${(i + 1) * (100 / ((data.numInputs || 2) + 1))}%` }, className: 'node-handle', isConnectable: isConnectable })); } return React.createElement('div', { className: 'base-node', style: { borderColor: '#4A90E2' }, onDoubleClick: handleDoubleClick }, React.createElement('div', null, data.label || 'Concatenar'), React.createElement('div', { className: 'functional-node-content', style: {fontSize: '11px', color: '#666'} }, `Salida: ${data.outputValue ? data.outputValue.substring(0, 30) : ''}${data.outputValue && data.outputValue.length > 30 ? '...' : ''}`), isEditing && React.createElement('input', { ref: inputRef, type: 'text', value: separator, onChange: handleChange, onKeyDown: handleKeyDown, onBlur: handleSaveConfig, className: 'node-config-input', placeholder: 'Separador (ej: , )', onClick: (e) => e.stopPropagation() }), ...inputHandles, React.createElement(Handle, { type: "source", position: Position.Right, id: "output", className: 'node-handle', isConnectable: isConnectable }) ); };
            const ResultNodeComponent = ({ data, isConnectable }) => React.createElement('div', { className: 'base-node', style: { borderColor: '#50E3C2' } }, React.createElement('div', null, data.label), React.createElement('div', { className: 'functional-node-content' }, data.inputValue || '(Vacío)'), React.createElement(Handle, { type: "target", position: Position.Left, id: "input", className: 'node-handle', isConnectable: isConnectable }) );
            const DownloadNodeComponent = ({ id, data, isConnectable }) => { const { setNodes, setNodesDraggable } = useReactFlow(); const [isEditing, setIsEditing] = React.useState(false); const [filename, setFilename] = React.useState(data.filename || 'datos.txt'); const inputRef = React.useRef(null); const handleDoubleClick = () => { setIsEditing(true); if(!data.locked) setNodesDraggable(false); }; const handleSaveConfig = () => { let changed = data.filename !== filename; setNodes(nds => nds.map(n => n.id === id ? { ...n, data: { ...n.data, filename: filename } } : n)); setIsEditing(false); if(!data.locked) setNodesDraggable(true); if(changed && window.recordAction) window.recordAction(); }; const handleChange = (e) => setFilename(e.target.value); const handleKeyDown = (e) => { if (e.key === 'Escape') { setFilename(data.filename || 'datos.txt'); setIsEditing(false); if(!data.locked) setNodesDraggable(true); } else if (e.key === 'Enter') { handleSaveConfig(); }}; React.useEffect(() => { if (isEditing && inputRef.current) { inputRef.current.focus(); inputRef.current.select(); }}, [isEditing]); const handleDownload = () => { const content = data.inputValue || ''; const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = data.filename || 'datos.txt'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }; return React.createElement('div', { className: 'base-node', style: { borderColor: '#F5A623' }, onDoubleClick: handleDoubleClick }, React.createElement('div', null, data.label + (isEditing ? '' : `: ${data.filename}`)), isEditing ? React.createElement('input', { ref: inputRef, type: 'text', value: filename, onChange: handleChange, onKeyDown: handleKeyDown, onBlur: handleSaveConfig, className: 'node-config-input', placeholder: 'nombre_archivo.txt', onClick: (e) => e.stopPropagation() }) : React.createElement('div', { className: 'functional-node-content', style:{fontSize:'11px', display: 'none'} }, `Archivo: ${data.filename}`), React.createElement('button', { onClick: handleDownload, className: 'functional-node-button' }, 'Descargar Contenido'), React.createElement(Handle, { type: "target", position: Position.Left, id: "input", className: 'node-handle', isConnectable: isConnectable }) ); };
            const TextTransformNode = ({ id, data, typeLabel, transformFn }) => { const nodeContent = () => React.createElement('div', { className: 'base-node', style: { borderColor: '#7ED321' } }, React.createElement('div', null, data.label || typeLabel), React.createElement('div', { className: 'functional-node-content', style: {fontSize: '11px', color: '#666'} }, `Entrada: ${(data.inputValue || '').substring(0,20)}...`), React.createElement('div', { className: 'functional-node-content', style: {fontSize: '11px', color: '#333', fontWeight: 'bold'} }, `Salida: ${(data.outputValue || '').substring(0,20)}...`), React.createElement(Handle, { type: "target", position: Position.Left, id: "input", className: 'node-handle' }), React.createElement(Handle, { type: "source", position: Position.Right, id: "output", className: 'node-handle' }) ); return React.createElement(NodeWrapper, { data: data }, nodeContent()); };
            const CapitalizeNodeComponent = (props) => React.createElement(TextTransformNode, { ...props, typeLabel: "Capitalizar" });
            const UppercaseNodeComponent = (props) => React.createElement(TextTransformNode, { ...props, typeLabel: "Mayúsculas" });
            const LowercaseNodeComponent = (props) => React.createElement(TextTransformNode, { ...props, typeLabel: "Minúsculas" });
            const ImageNodeWrapped = (props) => React.createElement(NodeWrapper, { data: props.data }, React.createElement(ImageNode, props));
            const ConcatenateNodeWrapped = (props) => React.createElement(NodeWrapper, { data: props.data }, React.createElement(ConcatenateNodeComponent, props));
            const ResultNodeWrapped = (props) => React.createElement(NodeWrapper, { data: props.data }, React.createElement(ResultNodeComponent, props));
            const DownloadNodeWrapped = (props) => React.createElement(NodeWrapper, { data: props.data }, React.createElement(DownloadNodeComponent, props));
            const CustomEdge = ({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, style = {}, data, markerEnd, label }) => { const { setEdges } = useReactFlow(); const edgePathStyle = { ...style }; let pathClassName = 'react-flow__edge-path'; if (data?.lineStyle === 'dashed') { edgePathStyle.strokeDasharray = '5 5'; } else if (data?.lineStyle === 'animated-dashed') { edgePathStyle.strokeDasharray = '5 5'; edgePathStyle.animation = 'dashdraw 0.7s linear infinite'; } else { delete edgePathStyle.strokeDasharray; delete edgePathStyle.animation; } const [edgePath, labelX, labelY] = getBezierPath({ sourceX, sourceY, sourcePosition, targetX, targetY, targetPosition }); const [isEditing, setIsEditing] = React.useState(false); const [edgeLabel, setEdgeLabel] = React.useState(label || ''); const inputRef = React.useRef(null); const onEdgeDoubleClick = React.useCallback((event) => { event.stopPropagation(); setIsEditing(true); }, []); const onLabelChange = (evt) => setEdgeLabel(evt.target.value); const onLabelSave = () => { let changed = label !== edgeLabel; setEdges((es) => es.map((edge) => edge.id === id ? { ...edge, label: edgeLabel } : edge)); setIsEditing(false); if(changed && window.recordAction) window.recordAction(); }; const onLabelKeyDown = (event) => { if (event.key === 'Enter') { onLabelSave(); } else if (event.key === 'Escape') { setEdgeLabel(label || ''); setIsEditing(false); }}; React.useEffect(() => { if (isEditing && inputRef.current) { inputRef.current.focus(); inputRef.current.select(); }}, [isEditing]); return React.createElement(React.Fragment, null, React.createElement('path', { id: id, style: edgePathStyle, className: pathClassName, d: edgePath, markerEnd: markerEnd }), React.createElement(EdgeLabelRenderer, null, isEditing ? React.createElement('div', { style: { position: 'absolute', transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`, pointerEvents: 'all' }, className: 'nodrag nopan' }, React.createElement('input', { ref: inputRef, value: edgeLabel, onChange: onLabelChange, onBlur: onLabelSave, onKeyDown: onLabelKeyDown, className: 'edge-label-input' })) : (label || edgeLabel) && React.createElement('div', { style: { position: 'absolute', transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`, background: 'var(--edge-label-bg)', padding: '2px 5px', borderRadius: '3px', fontSize: '10px', color: 'var(--edge-label-color)', pointerEvents: 'all' }, className: 'nodrag nopan', onDoubleClick: onEdgeDoubleClick }, label || edgeLabel) ) ); };
            
            const edgeTypes = { customEdge: CustomEdge }; // <<< --- ESTA LÍNEA ES LA CORRECCIÓN IMPORTANTE

            const FloatingHeaderContent = ({ onUndo, onRedo, canUndo, canRedo }) => { const undoIcon = React.createElement('svg', { viewBox:"0 0 24 24", fill:"none", stroke:"currentColor", strokeWidth:"2"}, React.createElement('path', {d:"M21 13H5.83l3.58-3.59L8 8l-6 6 6 6 1.41-1.41L5.83 15H21v-2z"})); const redoIcon = React.createElement('svg', { viewBox:"0 0 24 24", fill:"none", stroke:"currentColor", strokeWidth:"2"}, React.createElement('path', {d:"M3 13h15.17l-3.58-3.59L16 8l6 6-6 6-1.41-1.41L15.17 15H3v-2z"})); return React.createElement(React.Fragment, null, React.createElement(Panel, { position: 'top-left', className: 'logo-panel' }, 'XOCONODO'), React.createElement(Panel, { position: 'top-right', className: 'header-actions-panel' }, React.createElement('button', { onClick: onUndo, disabled: !canUndo, className: 'sidebar-button', title: 'Deshacer (Ctrl+Z)' }, undoIcon, 'Deshacer'), React.createElement('button', { onClick: onRedo, disabled: !canRedo, className: 'sidebar-button', title: 'Rehacer (Ctrl+Y)' }, redoIcon, 'Rehacer') ) ); };
            const LeftSidebar = ({ onAddNode, onAddImage, onAddConcatenateNode, onAddResultNode, onAddDownloadNode, addCapitalizeNode, addUppercaseNode, addLowercaseNode, autoLayout, onToggleAutoLayout, onRecenter, onImport, onExport, onShare }) => { const recenterIcon = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('path', {d:"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"})); const importIcon = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('path', {d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"})); const exportIcon = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('path', {d:"M12 15v8m-4-4l4 4 4-4m4-13H8a4 4 0 00-4 4v6"})); const shareIcon = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('circle',{cx:"18",cy:"5",r:"3"}), React.createElement('circle',{cx:"6",cy:"12",r:"3"}), React.createElement('circle',{cx:"18",cy:"19",r:"3"}), React.createElement('line',{x1:"8.59",y1:"13.51",x2:"15.42",y2:"17.49"}), React.createElement('line',{x1:"15.41",y1:"6.51",x2:"8.59",y2:"10.49"})); const imageIcon = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('rect',{x:"3",y:"3",width:"18",height:"18",rx:"2",ry:"2"}), React.createElement('circle',{cx:"8.5",cy:"8.5",r:"1.5"}), React.createElement('polyline',{points:"21 15 16 10 5 21"})); const concatIcon = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('path',{d:"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"}), React.createElement('path',{d:"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"})); const resultIcon = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('rect',{x:"3",y:"3",width:"18",height:"18",rx:"2"}), React.createElement('path',{d:"M8 12h8M8 16h4M8 8h8"})); const downloadIcon = React.createElement('svg', {viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('path',{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"}), React.createElement('polyline',{points:"7 10 12 15 17 10"}), React.createElement('line',{x1:"12",y1:"15",x2:"12",y2:"3"})); const textIcon = React.createElement('svg', {viewBox:"0 0 24 24", fill:"none", stroke:"currentColor", strokeWidth:"2"}, React.createElement('path', {d:"M17 6.1H3M17 12.1H3M10 18.1H3M21 6.1v7.7c0 1.7-1.6 2.7-3.2 2.7s-3.2-1-3.2-2.7V6.1M14.8 10.8h6.4"})); return React.createElement(Panel, { position: 'top-left', className: 'left-sidebar-panel', style: {marginTop: '70px'} }, React.createElement('button', { onClick: onAddNode, className: 'sidebar-button primary' }, React.createElement('span', { style: { fontSize: '18px', lineHeight: '1' } }, '+ '), ' Add Node'), React.createElement('button', { onClick: onAddImage, className: 'sidebar-button' }, imageIcon, ' Add Image'), React.createElement('button', { onClick: onAddConcatenateNode, className: 'sidebar-button' }, concatIcon, ' Add Concatenate'), React.createElement('button', { onClick: onAddResultNode, className: 'sidebar-button' }, resultIcon, ' Add Result'), React.createElement('button', { onClick: onAddDownloadNode, className: 'sidebar-button' }, downloadIcon, ' Add Download'), React.createElement('button', { onClick: addCapitalizeNode, className: 'sidebar-button' }, textIcon, ' Capitalizar'), React.createElement('button', { onClick: addUppercaseNode, className: 'sidebar-button' }, textIcon, ' Mayúsculas'), React.createElement('button', { onClick: addLowercaseNode, className: 'sidebar-button' }, textIcon, ' Minúsculas'), React.createElement('div', { className: 'sidebar-button auto-layout' }, React.createElement('label', { className: 'switch' }, React.createElement('input', { type: 'checkbox', checked: autoLayout, onChange: onToggleAutoLayout }), React.createElement('span', { className: 'slider' })), 'Rejilla'), React.createElement('button', { onClick: onRecenter, className: 'sidebar-button' }, recenterIcon, ' Recenter'), React.createElement('button', { onClick: onImport, className: 'sidebar-button' }, importIcon, ' Import'), React.createElement('button', { onClick: onExport, className: 'sidebar-button' }, exportIcon, ' Export'), React.createElement('button', { onClick: onShare, className: 'sidebar-button' }, shareIcon, ' Share') ); };
            const ToolsToolbar = ({ selectedElement, onSelectShape, selectedShape, onSelectColor, selectedColor, onSelectBorderColor, selectedBorderColor, onSelectBorderStyle, selectedBorderStyle, onSelectEdgeType, selectedEdgeType, onSelectEdgeLineStyle, selectedEdgeLineStyle, onDeleteSelectedElements, onDuplicateSelected }) => { const shapes = [ { type: 'rect', iconClass: 'rect' }, { type: 'circle', iconClass: 'circle' }, { type: 'diamond', iconClass: 'diamond' }]; const colors = ['#ffffff', '#f0f0f0', '#d1ecff', '#d6f5d6', '#fff8c5', '#ffe6e6']; const borderColors = ['#FF0066', '#333333', '#3b82f6', '#16a34a', '#f59e0b', '#ef4444']; const borderStyles = ['solid', 'dashed', 'dotted', 'none']; const edgeTypesList = [ { type: 'customEdge', name: 'Bezier (Edit)' }, { type: 'smoothstep', name: 'SmoothStep' }, { type: 'step', name: 'Step' }, { type: 'straight', name: 'Straight' } ]; const edgeLineStylesList = [ { type: 'solid', name: 'Solid' }, { type: 'dashed', name: 'Dashed' }, { type: 'animated-dashed', name: 'Animated Dashed' }]; const trashIcon = React.createElement('svg', {width:"18",height:"18",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('path', {d:"M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"})); const duplicateIcon = React.createElement('svg', {width:"18",height:"18",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2"}, React.createElement('rect',{x:"8",y:"8",width:"12",height:"12",rx:"2",ry:"2"}), React.createElement('path',{d:"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"})); const isTextNodeSelected = selectedElement && selectedElement.isNode && selectedElement.type === 'customNode'; const isImageNodeSelected = selectedElement && selectedElement.isNode && selectedElement.type === 'imageNode'; const isEdgeSelected = selectedElement && selectedElement.isEdge; const nodeToolsDisabled = isEdgeSelected || isImageNodeSelected || (selectedElement && selectedElement.isNode && (selectedElement.type === 'concatenateNode' || selectedElement.type === 'resultNode' || selectedElement.type === 'downloadNode' || selectedElement.type === 'capitalizeNode' || selectedElement.type === 'uppercaseNode' || selectedElement.type === 'lowercaseNode')); const edgeToolsDisabled = selectedElement && selectedElement.isNode; const canDuplicate = selectedElement && (selectedElement.isNode || (selectedElement.multiple && selectedElement.isNode)); const canDelete = selectedElement && (selectedElement.isNode || selectedElement.isEdge || selectedElement.multiple); return React.createElement(Panel, { position: 'top-center', className: 'tools-toolbar-panel', style:{marginTop: '10px'} } , React.createElement('div', {className: 'toolbar-group'}, React.createElement('span', {className: 'toolbar-group-label'}, 'Node (Text):'), shapes.map(s => React.createElement('div', { key: s.type, className: `tool-button ${selectedShape === s.type && isTextNodeSelected ? 'selected' : ''}`, onClick: () => onSelectShape(s.type), title: `Forma: ${s.type}`, style: { opacity: nodeToolsDisabled ? 0.5 : 1, pointerEvents: nodeToolsDisabled ? 'none' : 'auto' } }, React.createElement('div', { className: `tool-icon ${s.iconClass}` }))), React.createElement('div', { className: 'tools-toolbar-divider' }), colors.map(c => React.createElement('div', { key: `bg-${c}`, className: `tool-button ${selectedColor === c && isTextNodeSelected ? 'selected' : ''}`, onClick: () => onSelectColor(c), title: c, style: { opacity: nodeToolsDisabled ? 0.5 : 1, pointerEvents: nodeToolsDisabled ? 'none' : 'auto' }  }, React.createElement('div', { className: 'tool-color', style: { backgroundColor: c } }))), React.createElement('div', { className: 'tools-toolbar-divider' }), borderColors.map(bc => React.createElement('div', { key: `bcol-${bc}`, className: `tool-button ${selectedBorderColor === bc && isTextNodeSelected ? 'selected' : ''}`, onClick: () => onSelectBorderColor(bc), title: bc, style: { opacity: nodeToolsDisabled ? 0.5 : 1, pointerEvents: nodeToolsDisabled ? 'none' : 'auto' }  }, React.createElement('div', { className: 'tool-color', style: { backgroundColor: bc } }))), React.createElement('div', { className: 'tools-toolbar-divider' }), borderStyles.map(bs => React.createElement('div', { key: bs, className: `tool-button ${selectedBorderStyle === bs && isTextNodeSelected ? 'selected' : ''}`, onClick: () => onSelectBorderStyle(bs), title: bs, style: { opacity: nodeToolsDisabled ? 0.5 : 1, pointerEvents: nodeToolsDisabled ? 'none' : 'auto' }  }, React.createElement('div', { className: 'tool-icon', style: { border: `2px ${bs} #333`, width:'20px', height:'20px', borderRadius: bs === 'dotted' ? '50%' : '3px' } }))) ), React.createElement('div', {className: 'toolbar-group'}, React.createElement('span', {className: 'toolbar-group-label'}, 'Edge Type:'), edgeTypesList.map(et => React.createElement('button', { key: et.type, className: `tool-button ${selectedEdgeType === et.type && (isEdgeSelected || !selectedElement || selectedElement.multiple) ? 'selected' : ''}`, onClick: () => onSelectEdgeType(et.type), title: `Tipo: ${et.name}`, style: { opacity: edgeToolsDisabled ? 0.5 : 1, pointerEvents: edgeToolsDisabled ? 'none' : 'auto' }  }, et.name)) ), React.createElement('div', {className: 'toolbar-group'}, React.createElement('span', {className: 'toolbar-group-label'}, 'Line Style:'), edgeLineStylesList.map(els => React.createElement('button', { key: els.type, className: `tool-button ${selectedEdgeLineStyle === els.type && (isEdgeSelected || !selectedElement || selectedElement.multiple) ? 'selected' : ''}`, onClick: () => onSelectEdgeLineStyle(els.type), title: `Línea: ${els.name}`, style: { opacity: edgeToolsDisabled ? 0.5 : 1, pointerEvents: edgeToolsDisabled ? 'none' : 'auto' }  }, els.name)) ), React.createElement('div', {className: 'toolbar-group'}, React.createElement('div', { className: 'tool-button', onClick: onDeleteSelectedElements, title: "Eliminar (Supr)", disabled: !canDelete }, React.createElement('div', { className: 'tool-icon trash' }, trashIcon)), React.createElement('div', { className: 'tool-button', onClick: onDuplicateSelected, title: "Duplicar (Ctrl+D)", disabled: !canDuplicate }, duplicateIcon) ) ); };
            const getEdgeStyleObject = (lineStyleType, strokeColor) => { const baseStyle = { stroke: strokeColor || '#FF0066', strokeWidth: 2 }; if (lineStyleType === 'dashed') { return { ...baseStyle, strokeDasharray: '5 5', animation: 'none' }; } else if (lineStyleType === 'animated-dashed') { return { ...baseStyle, strokeDasharray: '5 5', animation: 'dashdraw 0.7s linear infinite' }; } return { ...baseStyle, strokeDasharray: 'none', animation: 'none' }; };

            const FlowApp = () => {
                const [nodes, setNodes, onNodesChangeInternal] = useNodesState(initialNodes);
                const [edges, setEdges, onEdgesChangeInternal] = useEdgesState(initialEdges);
                const { project, getViewport, setViewport, zoomIn, zoomOut, fitView, getNodes, getEdges, deleteElements: rfDeleteElementsHook, getNode, getEdge } = useReactFlow();
                const [contextMenu, setContextMenu] = React.useState(null);
                React.useEffect(() => { setTimeout(() => setViewport(initialViewport, { duration: 0 }),0); }, [setViewport]);
                const [autoLayout, setAutoLayout] = React.useState(false);
                const [backgroundVariant, setBackgroundVariant] = React.useState('dots');
                const [selectedShape, setSelectedShape] = React.useState('rect');
                const [selectedColor, setSelectedColor] = React.useState('#ffffff');
                const [selectedBorderColor, setSelectedBorderColor] = React.useState('#FF0066');
                const [selectedBorderStyle, setSelectedBorderStyle] = React.useState('solid');
                const [selectedEdgeType, setSelectedEdgeType] = React.useState('customEdge');
                const [selectedEdgeLineStyle, setSelectedEdgeLineStyle] = React.useState('solid');
                const [selectedElement, setSelectedElement] = React.useState(null);
                const [clipboard, setClipboard] = React.useState(null);
                const MAX_HISTORY_LENGTH = 50;
                const historyRef = React.useRef([{ nodes: [...initialNodes], edges: [...initialEdges], viewport: {...initialViewport} }]);
                const historyIndexRef = React.useRef(0);
                const [canUndo, setCanUndo] = React.useState(false);
                const [canRedo, setCanRedo] = React.useState(false);
                const updateUndoRedoState = React.useCallback(() => { setCanUndo(historyIndexRef.current > 0); setCanRedo(historyIndexRef.current < historyRef.current.length - 1); }, []);
                window.recordAction = React.useCallback(() => { setTimeout(() => { const currentNodes = getNodes().map(n => ({...n})); const currentEdges = getEdges().map(e => ({...e})); const currentViewport = getViewport(); const lastStateInHistory = historyRef.current[historyIndexRef.current]; if (JSON.stringify(lastStateInHistory.nodes) === JSON.stringify(currentNodes) && JSON.stringify(lastStateInHistory.edges) === JSON.stringify(currentEdges) && JSON.stringify(lastStateInHistory.viewport) === JSON.stringify(currentViewport)) { return; } const newHistoryStack = historyRef.current.slice(0, historyIndexRef.current + 1); newHistoryStack.push({ nodes: currentNodes, edges: currentEdges, viewport: currentViewport }); if (newHistoryStack.length > MAX_HISTORY_LENGTH) { historyRef.current = newHistoryStack.slice(-MAX_HISTORY_LENGTH); } else { historyRef.current = newHistoryStack; } historyIndexRef.current = historyRef.current.length - 1; updateUndoRedoState(); }, 0); }, [getNodes, getEdges, getViewport, updateUndoRedoState]); 
                const handleUndo = React.useCallback(() => { if (historyIndexRef.current > 0) { historyIndexRef.current -= 1; const prevState = historyRef.current[historyIndexRef.current]; setNodes(prevState.nodes.map(n => ({...n}))); setEdges(prevState.edges.map(e => ({...e}))); setViewport(prevState.viewport, {duration: 100}); updateUndoRedoState(); } }, [setNodes, setEdges, setViewport, updateUndoRedoState]);
                const handleRedo = React.useCallback(() => { if (historyIndexRef.current < historyRef.current.length - 1) { historyIndexRef.current += 1; const nextState = historyRef.current[historyIndexRef.current]; setNodes(nextState.nodes.map(n => ({...n}))); setEdges(nextState.edges.map(e => ({...e}))); setViewport(nextState.viewport, {duration: 100}); updateUndoRedoState(); } }, [setNodes, setEdges, setViewport, updateUndoRedoState]);
                React.useEffect(() => { updateUndoRedoState(); }, []);
                window.getSelectedEdgeLineStyle = () => selectedEdgeLineStyle;
                const updateNodeLabel = React.useCallback((nodeId, newLabel) => { setNodes((nds) => nds.map((node) => (node.id === nodeId && node.type === 'customNode') ? { ...node, data: { ...node.data, label: newLabel, outputValue: newLabel } } : node )); }, [setNodes]);
                const memoizedNodeTypes = React.useMemo(() => ({ customNode: CustomNode, imageNode: ImageNodeWrapped, concatenateNode: ConcatenateNodeWrapped, resultNode: ResultNodeWrapped, downloadNode: DownloadNodeWrapped, capitalizeNode: CapitalizeNodeComponent, uppercaseNode: UppercaseNodeComponent, lowercaseNode: LowercaseNodeComponent }), [updateNodeLabel]); 
                const onNodeContextMenu = React.useCallback((event, node) => { event.preventDefault(); setContextMenu({ id: node.id, top: event.clientY, left: event.clientX, nodeData: node.data, }); }, [setContextMenu]);
                const closeContextMenu = () => setContextMenu(null);
                const toggleNodeLock = (nodeId) => { setNodes((nds) => nds.map((n) => { if (n.id === nodeId) { return { ...n, data: { ...n.data, locked: !n.data.locked }, draggable: n.data.locked }; } return n; })); if(window.recordAction) window.recordAction(); closeContextMenu(); };
                const onNodesChange = React.useCallback((changes) => { const procesedChanges = changes.map(change => { if (change.type === 'position' && change.id) { const node = getNode(change.id); if (node && node.data.locked) { return null; }} return change; }).filter(Boolean); if (procesedChanges.length > 0) { onNodesChangeInternal(procesedChanges); procesedChanges.forEach(change => { if (change.type === 'position' && change.dragging === false) { if(window.recordAction) window.recordAction(); } }); } }, [onNodesChangeInternal, getNode]);
                window.onAddNodeAndEdgeFromCustomNode = React.useCallback((newNode, newEdge) => { const edgeData = { ...newEdge.data, lineStyle: selectedEdgeLineStyle }; const edgeStyle = getEdgeStyleObject(selectedEdgeLineStyle, newEdge.style.stroke); setNodes(nds => nds.concat(newNode)); setEdges(eds => addEdge({...newEdge, data: edgeData, style: {...newEdge.style, ...edgeStyle}, type: selectedEdgeType || 'customEdge', label: ''}, eds)); if(window.recordAction) window.recordAction(); }, [setNodes, setEdges, selectedEdgeType, selectedEdgeLineStyle]);
                const onEdgesChange = React.useCallback((changes) => { onEdgesChangeInternal(changes); if (changes.some(c => c.type === 'remove')) { if(window.recordAction) window.recordAction(); } }, [onEdgesChangeInternal]);
                const onConnect = React.useCallback((params) => { const edgeData = { lineStyle: selectedEdgeLineStyle }; const edgeStyle = getEdgeStyleObject(selectedEdgeLineStyle, selectedBorderColor); setEdges((eds) => addEdge({ ...params, type: selectedEdgeType || 'customEdge', data: edgeData, label: '', style: edgeStyle, markerEnd: { type: MarkerType.ArrowClosed, color: selectedBorderColor } }, eds)); if(window.recordAction) window.recordAction(); }, [setEdges, selectedBorderColor, selectedEdgeType, selectedEdgeLineStyle]);
                const getNewNodePosition = () => { const { x: viewX, y: viewY, zoom } = getViewport(); const targetX = (window.innerWidth / 2 - viewX) / zoom; const targetY = (window.innerHeight / (2 * 0.85) - viewY) / zoom; return { x: targetX - 75, y: targetY - 25 }; };
                const addNodeHelper = (createNodeFn, data = {}) => { nodeIdCounter++; const pos = getNewNodePosition(); setNodes(nds => nds.concat(createNodeFn(nodeIdCounter.toString(), pos, data))); if(window.recordAction) window.recordAction(); };
                const addNodeHandler = React.useCallback(() => addNodeHelper(createNewNode, { label: `Node ${nodeIdCounter + 1}`, shape: selectedShape, color: selectedColor, borderColor: selectedBorderColor, borderStyle: selectedBorderStyle }), [selectedShape, selectedColor, selectedBorderColor, selectedBorderStyle]);
                const addImageHandler = React.useCallback(() => { const input = document.createElement('input'); input.type = 'file'; input.accept = 'image/*'; input.onchange = e => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = event => { const imgSrc = event.target.result; const img = new Image(); img.onload = () => { nodeIdCounter++; const pos = getNewNodePosition(); const initialWidth = Math.min(200, img.naturalWidth); const initialHeight = (img.naturalHeight / img.naturalWidth) * initialWidth; setNodes(nds => nds.concat(createNewImageNode(nodeIdCounter.toString(), {x: pos.x - initialWidth/2 + 75, y: pos.y - initialHeight/2 + 25}, { src: imgSrc, width: initialWidth, height: initialHeight, originalWidth: img.naturalWidth, originalHeight: img.naturalHeight }))); if(window.recordAction) window.recordAction(); }; img.src = imgSrc; }; reader.readAsDataURL(file); } }; input.click(); }, []);
                const addConcatenateNodeHandler = React.useCallback(() => addNodeHelper(createConcatenateNode), []);
                const addResultNodeHandler = React.useCallback(() => addNodeHelper(createResultNode), []);
                const addDownloadNodeHandler = React.useCallback(() => addNodeHelper(createDownloadNode), []);
                const addCapitalizeNodeHandler = React.useCallback(() => addNodeHelper(createCapitalizeNode), []);
                const addUppercaseNodeHandler = React.useCallback(() => addNodeHelper(createUppercaseNode), []);
                const addLowercaseNodeHandler = React.useCallback(() => addNodeHelper(createLowercaseNode), []);
                const handleCopySelected = React.useCallback(() => { const selectedNodesToCopy = getNodes().filter(n => n.selected); if (selectedNodesToCopy.length === 0) { setClipboard(null); return; } const copiedNodes = JSON.parse(JSON.stringify(selectedNodesToCopy.map(n => ({ ...n, selected: false })))); const selectedNodeIds = new Set(selectedNodesToCopy.map(n => n.id)); const copiedEdges = JSON.parse(JSON.stringify(getEdges().filter(edge => selectedNodeIds.has(edge.source) && selectedNodeIds.has(edge.target)).map(e => ({ ...e, selected: false })))); setClipboard({ nodes: copiedNodes, edges: copiedEdges }); }, [getNodes, getEdges]);
                const handlePaste = React.useCallback(() => { if (!clipboard || clipboard.nodes.length === 0) return; const { x: viewX, y: viewY, zoom } = getViewport(); const PADDING = 20; const firstNodeInClipboard = clipboard.nodes[0]; const pasteBaseX = (window.innerWidth / 2 - viewX) / zoom - (firstNodeInClipboard.width || 150) / (2*zoom) + PADDING / zoom; const pasteBaseY = (window.innerHeight / 3 - viewY) / zoom - (firstNodeInClipboard.height || 40) / (2*zoom) + PADDING / zoom; const newNodes = []; const idMapping = new Map(); clipboard.nodes.forEach((nodeToCopy) => { nodeIdCounter++; const newNodeId = nodeIdCounter.toString(); idMapping.set(nodeToCopy.id, newNodeId); const dx = nodeToCopy.position.x - firstNodeInClipboard.position.x; const dy = nodeToCopy.position.y - firstNodeInClipboard.position.y; newNodes.push({ ...nodeToCopy, id: newNodeId, position: { x: pasteBaseX + dx, y: pasteBaseY + dy }, selected: true, data: { ...nodeToCopy.data } }); }); const newEdges = clipboard.edges.map(edgeToCopy => { nodeIdCounter++; return { ...edgeToCopy, id: `e-${nodeIdCounter}`, source: idMapping.get(edgeToCopy.source), target: idMapping.get(edgeToCopy.target), selected: false }; }); setNodes(nds => nds.map(n => ({...n, selected: false})).concat(newNodes)); setEdges(eds => eds.map(e => ({...e, selected: false})).concat(newEdges)); if(window.recordAction) window.recordAction(); }, [clipboard, getViewport, setNodes, setEdges]);
                const handleDuplicateSelected = React.useCallback(() => { const selectedNodesToDuplicate = getNodes().filter(n => n.selected); if (selectedNodesToDuplicate.length === 0) return; const OFFSET = 30; const newNodes = []; const idMapping = new Map(); selectedNodesToDuplicate.forEach((nodeToDuplicate) => { nodeIdCounter++; const newNodeId = nodeIdCounter.toString(); idMapping.set(nodeToDuplicate.id, newNodeId); newNodes.push(JSON.parse(JSON.stringify({ ...nodeToDuplicate, id: newNodeId, position: { x: nodeToDuplicate.position.x + OFFSET, y: nodeToDuplicate.position.y + OFFSET }, selected: true }))); }); const selectedNodeIds = new Set(selectedNodesToDuplicate.map(n => n.id)); const newEdges = getEdges().filter(edge => selectedNodeIds.has(edge.source) && selectedNodeIds.has(edge.target)).map(edgeToDuplicate => { nodeIdCounter++; return JSON.parse(JSON.stringify({ ...edgeToDuplicate, id: `e-${nodeIdCounter}`, source: idMapping.get(edgeToDuplicate.source), target: idMapping.get(edgeToDuplicate.target), selected: false })); }); setNodes(nds => nds.map(n => ({...n, selected: false})).concat(newNodes)); setEdges(eds => eds.concat(newEdges)); if(window.recordAction) window.recordAction(); }, [getNodes, getEdges, setNodes, setEdges]);
                const handlePasteFromClipboard = React.useCallback((event) => { const items = (event.clipboardData || event.originalEvent.clipboardData).items; for (let index in items) { const item = items[index]; if (item.kind === 'file' && item.type.startsWith('image/')) { event.preventDefault(); const blob = item.getAsFile(); const reader = new FileReader(); reader.onload = (e) => { const imgSrc = e.target.result; const img = new Image(); img.onload = () => { nodeIdCounter++; const { x: viewX, y: viewY, zoom } = getViewport(); const reactFlowBounds = document.getElementById('reactflow-root').getBoundingClientRect(); const targetX = (event.clientX - reactFlowBounds.left - viewX) / zoom; const targetY = (event.clientY - reactFlowBounds.top - viewY) / zoom; const initialWidth = Math.min(200, img.naturalWidth); const initialHeight = (img.naturalHeight / img.naturalWidth) * initialWidth; setNodes(nds => nds.concat(createNewImageNode(nodeIdCounter.toString(), {x: targetX - initialWidth/2, y: targetY - initialHeight/2}, { src: imgSrc, width: initialWidth, height: initialHeight, originalWidth: img.naturalWidth, originalHeight: img.naturalHeight }))); if(window.recordAction) window.recordAction(); }; img.src = imgSrc; }; reader.readAsDataURL(blob); return; } } }, [getViewport, setNodes]);
                React.useEffect(() => { document.addEventListener('paste', handlePasteFromClipboard); return () => document.removeEventListener('paste', handlePasteFromClipboard); }, [handlePasteFromClipboard]);
                const deleteSelectedElementsHandler = React.useCallback(() => { const selNodes = getNodes().filter(n => n.selected); const selEdges = getEdges().filter(e => e.selected); if (selNodes.length > 0 || selEdges.length > 0) { rfDeleteElementsHook({ nodes: selNodes, edges: selEdges }); setSelectedElement(null); if(window.recordAction) window.recordAction(); } }, [getNodes, getEdges, rfDeleteElementsHook]);
                React.useEffect(() => { const handleKeyDownGlobal = (event) => { const activeEl = document.activeElement; const isInputFocused = activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA'; if ((event.ctrlKey || event.metaKey)) { switch (event.key.toLowerCase()) { case 'c': if (!isInputFocused) { event.preventDefault(); handleCopySelected(); } break; case 'v': if (!isInputFocused) { event.preventDefault(); handlePaste(); } break; case 'd': if (!isInputFocused) { event.preventDefault(); handleDuplicateSelected(); } break; case 'z': event.preventDefault(); (event.shiftKey ? handleRedo() : handleUndo()); break; case 'y': event.preventDefault(); handleRedo(); break; } } else if (event.key === 'Delete' || event.key === 'Backspace') { if (!isInputFocused && (selectedElement?.isNode || selectedElement?.isEdge || selectedElement?.multiple)) { event.preventDefault(); deleteSelectedElementsHandler(); } } }; document.addEventListener('keydown', handleKeyDownGlobal); return () => document.removeEventListener('keydown', handleKeyDownGlobal); }, [handleCopySelected, handlePaste, handleDuplicateSelected, handleUndo, handleRedo, selectedElement, deleteSelectedElementsHandler]); 
                const toggleAutoLayoutHandler = React.useCallback(() => { const newAutoLayoutState = !autoLayout; setAutoLayout(newAutoLayoutState); setBackgroundVariant(newAutoLayoutState ? 'lines' : 'dots'); if (newAutoLayoutState) { const currentNodes = getNodes(); const nodeCount = currentNodes.length; if (nodeCount === 0) return; const flowPane = document.getElementById('reactflow-root'); if(!flowPane) return; const { width, height } = flowPane.getBoundingClientRect(); const { zoom } = getViewport(); const centerX = width / (2 * zoom); const centerY = height / (2 * zoom); const radius = Math.min(centerX, centerY) * 0.5 * Math.max(0.4, nodeCount/8); const newNodes = currentNodes.map((node, i) => ({ ...node, position: { x: centerX + radius * Math.cos(i * 2 * Math.PI / nodeCount) - (node.width || 150) / (2 * zoom), y: centerY + radius * Math.sin(i * 2 * Math.PI / nodeCount) - (node.height || 50) / (2 * zoom) } })); setNodes(newNodes); setTimeout(() => fitView({ padding: 0.3, duration: 500 }), 100); } if(window.recordAction) window.recordAction(); }, [autoLayout, getNodes, setNodes, getViewport, fitView, setBackgroundVariant]);
                const recenterHandler = React.useCallback(() => fitView({ padding: 0.2, duration: 300 }), [fitView]);
                const importHandler = React.useCallback(() => { const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; input.onchange = e => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = event => { try { const flow = JSON.parse(event.target.result); const processedNodes = (flow.nodes || []).map(n => (n.type === 'imageNode') ? {...n, style: { width: n.data.width, height: n.data.height, ...n.style}} : n); const processedEdges = (flow.edges || []).map(edge => { const style = getEdgeStyleObject(edge.data?.lineStyle || 'solid', edge.style?.stroke || selectedBorderColor); return { ...edge, style: { ...edge.style, ...style } }; }); const importedViewport = flow.viewport || initialViewport; setNodes(processedNodes); setEdges(processedEdges); setViewport(importedViewport, {duration: 0}); nodeIdCounter = (processedNodes || []).reduce((maxId, node) => Math.max(maxId, parseInt(node.id.replace(/[^0-9]/g, '')) || 0), 0); nodeIdCounter = Math.max(nodeIdCounter, (processedEdges || []).reduce((maxId, edge) => Math.max(maxId, parseInt(edge.id.replace(/[^0-9]/g, '')) || 0), 0)); historyRef.current = [{ nodes: processedNodes, edges: processedEdges, viewport: importedViewport }]; historyIndexRef.current = 0; updateUndoRedoState(); setTimeout(() => fitView({ padding: 0.2, duration: 300 }), 50); } catch (err) { alert('Error al importar archivo JSON.'); console.error(err); } }; reader.readAsText(file); } }; input.click(); }, [setNodes, setEdges, setViewport, fitView, selectedBorderColor, updateUndoRedoState]);
                const exportHandler = React.useCallback(() => { const flow = { nodes: getNodes(), edges: getEdges(), viewport: getViewport() }; const dataStr = JSON.stringify(flow, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'xoconodo.json'; a.click(); URL.revokeObjectURL(url); }, [getNodes, getEdges, getViewport]);
                const shareHandler = React.useCallback(() => { try { const flow = { nodes: getNodes(), edges: getEdges(), viewport: getViewport() }; const flowString = JSON.stringify(flow); const encodedFlow = encodeURIComponent(btoa(flowString)); const shareUrl = `${window.location.origin}${window.location.pathname}?flow=${encodedFlow}`; navigator.clipboard.writeText(shareUrl).then(() => { alert('¡Enlace para compartir copiado al portapapeles!\nPuedes pegarlo en una nueva pestaña o enviarlo.'); }).catch(err => { console.error('Error al copiar al portapapeles: ', err); prompt('Copia este enlace para compartir:', shareUrl); }); if (shareUrl.length > 2000) { console.warn("La URL para compartir es muy larga y podría no funcionar en todos los navegadores/plataformas."); } } catch (e) { console.error("Error al generar enlace para compartir:", e); alert("Error al generar el enlace para compartir."); } }, [getNodes, getEdges, getViewport]);
                React.useEffect(() => { if (selectedElement && selectedElement.isNode && selectedElement.type === 'customNode') { const node = getNode(selectedElement.id); if (node && (node.data.shape !== selectedShape || node.data.color !== selectedColor || node.data.borderColor !== selectedBorderColor || node.data.borderStyle !== selectedBorderStyle)) { setNodes(nds => nds.map(n => n.id === node.id ? { ...n, data: { ...n.data, shape: selectedShape, color: selectedColor, borderColor: selectedBorderColor, borderStyle: selectedBorderStyle } } : n )); if(window.recordAction) window.recordAction(); } } }, [selectedShape, selectedColor, selectedBorderColor, selectedBorderStyle, selectedElement, getNode, setNodes]);
                const handleSelectEdgeType = (newType) => { setSelectedEdgeType(newType); if (selectedElement && selectedElement.isEdge) { setEdges(eds => eds.map(e => e.id === selectedElement.id ? { ...e, type: newType } : e)); if(window.recordAction) window.recordAction(); } };
                const handleSelectEdgeLineStyle = (newLineStyle) => { setSelectedEdgeLineStyle(newLineStyle); if (selectedElement && selectedElement.isEdge) { setEdges(eds => eds.map(e => { if (e.id === selectedElement.id) { const newEdgeStyle = getEdgeStyleObject(newLineStyle, e.style.stroke); return { ...e, data: { ...e.data, lineStyle: newLineStyle }, style: { ...e.style, ...newEdgeStyle } }; } return e; })); if(window.recordAction) window.recordAction(); } };
                const onSelectionChange = React.useCallback(({ nodes: selNodes, edges: selEdges }) => { if (selNodes.length === 1 && selEdges.length === 0) { const node = selNodes[0]; setSelectedElement({ id: node.id, isNode: true, type: node.type }); if (node.type === 'customNode') { setSelectedShape(node.data.shape); setSelectedColor(node.data.color); setSelectedBorderColor(node.data.borderColor); setSelectedBorderStyle(node.data.borderStyle); } } else if (selEdges.length === 1 && selNodes.length === 0) { const edge = selEdges[0]; setSelectedElement({ id: edge.id, isEdge: true }); setSelectedEdgeType(edge.type || 'customEdge'); setSelectedEdgeLineStyle(edge.data?.lineStyle || 'solid'); setSelectedBorderColor(edge.style?.stroke || '#FF0066'); } else if (selNodes.length > 0 || selEdges.length > 0) { setSelectedElement({ isNode: selNodes.length > 0, isEdge: selEdges.length > 0, multiple: true }); } else { setSelectedElement(null); } }, [setSelectedBorderColor]);
                React.useEffect(() => { let changedInPropagation = false; const currentNodesSnapshot = getNodes(); const currentEdgesSnapshot = getEdges(); const nodeMap = new Map(currentNodesSnapshot.map(n => [n.id, n])); const updatedNodesArray = currentNodesSnapshot.map(node => { let updatedNodeData = { ...node.data }; let nodeDataChangedThisIteration = false; let newInputValue = ''; if (['resultNode', 'downloadNode', 'capitalizeNode', 'uppercaseNode', 'lowercaseNode'].includes(node.type)) { const incomingEdge = currentEdgesSnapshot.find(edge => edge.target === node.id && edge.targetHandle === 'input'); if (incomingEdge) { const sourceNode = nodeMap.get(incomingEdge.source); if (sourceNode) { newInputValue = sourceNode.data.outputValue !== undefined ? sourceNode.data.outputValue : (sourceNode.data.label || ''); } } if (updatedNodeData.inputValue !== newInputValue) { updatedNodeData.inputValue = newInputValue; nodeDataChangedThisIteration = true; } } if (node.type === 'concatenateNode') { const incomingEdges = currentEdgesSnapshot.filter(edge => edge.target === node.id); const newInputs = {}; for (let i = 0; i < (node.data.numInputs || 2); i++) { const handleId = `input_${i}`; const edge = incomingEdges.find(e => e.targetHandle === handleId); if (edge) { const sourceNode = nodeMap.get(edge.source); if (sourceNode) { newInputs[handleId] = sourceNode.data.outputValue !== undefined ? sourceNode.data.outputValue : (sourceNode.data.label || ''); } else { newInputs[handleId] = ''; } } else { newInputs[handleId] = ''; } } if (JSON.stringify(newInputs) !== JSON.stringify(node.data.inputs) || node.data.separator !== updatedNodeData.separator) { const separator = updatedNodeData.separator || node.data.separator || ''; const concatenatedValue = Object.values(newInputs).filter(v => typeof v === 'string' && v !== '').join(separator); updatedNodeData.inputs = newInputs; updatedNodeData.outputValue = concatenatedValue; nodeDataChangedThisIteration = true; } } else if (node.type === 'capitalizeNode') { const newOutput = typeof updatedNodeData.inputValue === 'string' && updatedNodeData.inputValue.length > 0 ? updatedNodeData.inputValue.charAt(0).toUpperCase() + updatedNodeData.inputValue.slice(1).toLowerCase() : ''; if (updatedNodeData.outputValue !== newOutput) { updatedNodeData.outputValue = newOutput; nodeDataChangedThisIteration = true; } } else if (node.type === 'uppercaseNode') { const newOutput = typeof updatedNodeData.inputValue === 'string' ? updatedNodeData.inputValue.toUpperCase() : ''; if (updatedNodeData.outputValue !== newOutput) { updatedNodeData.outputValue = newOutput; nodeDataChangedThisIteration = true; } } else if (node.type === 'lowercaseNode') { const newOutput = typeof updatedNodeData.inputValue === 'string' ? updatedNodeData.inputValue.toLowerCase() : ''; if (updatedNodeData.outputValue !== newOutput) { updatedNodeData.outputValue = newOutput; nodeDataChangedThisIteration = true; } } if (nodeDataChangedThisIteration) { changedInPropagation = true; return { ...node, data: updatedNodeData }; } return node; }); if (changedInPropagation) { setNodes(updatedNodesArray, { replace: true }); } }, [nodes, edges, getNodes, getEdges, setNodes]);

                return React.createElement(React.Fragment, null, 
                    React.createElement('div', { className: 'main-content', onClick: closeContextMenu },
                        React.createElement(ReactFlowComponent, {
                            nodes: nodes.map(n => ({ ...n, draggable: !n.data.locked })), // Establecer draggable basado en n.data.locked
                            edges: edges, onNodesChange: onNodesChange, onEdgesChange: onEdgesChange, onConnect: onConnect, onSelectionChange: onSelectionChange,
                            onNodeContextMenu: onNodeContextMenu, 
                            nodeTypes: memoizedNodeTypes, edgeTypes: edgeTypes,
                            attributionPosition: null, 
                            deleteKeyCode: null, 
                            elementsSelectable: true, 
                            defaultEdgeOptions: { type: 'customEdge', label: '', style: { stroke: selectedBorderColor, strokeWidth: 2 }, markerEnd: { type: MarkerType.ArrowClosed, color: selectedBorderColor } },
                            connectionLineStyle: getEdgeStyleObject(selectedEdgeLineStyle, selectedBorderColor),
                            connectionLineType: 'customEdge',
                            onPaneClick: () => { setSelectedElement(null); closeContextMenu(); },
                        },
                            React.createElement(FloatingHeaderContent, { onUndo: handleUndo, onRedo: handleRedo, canUndo: canUndo, canRedo: canRedo }),
                            React.createElement(LeftSidebar, { onAddNode: addNodeHandler, onAddImage: addImageHandler, onAddConcatenateNode: addConcatenateNodeHandler, onAddResultNode: addResultNodeHandler, onAddDownloadNode: addDownloadNodeHandler, addCapitalizeNode: addCapitalizeNodeHandler, addUppercaseNode: addUppercaseNodeHandler, addLowercaseNode: addLowercaseNodeHandler, autoLayout, onToggleAutoLayout: toggleAutoLayoutHandler, onRecenter: recenterHandler, onImport: importHandler, onExport: exportHandler, onShare: shareHandler }),
                            React.createElement(ToolsToolbar, { selectedElement, selectedShape, onSelectShape: setSelectedShape, selectedColor, onSelectColor: setSelectedColor, selectedBorderColor, onSelectBorderColor: setSelectedBorderColor, selectedBorderStyle, onSelectBorderStyle: setSelectedBorderStyle, selectedEdgeType, onSelectEdgeType: handleSelectEdgeType, selectedEdgeLineStyle, onSelectEdgeLineStyle: handleSelectEdgeLineStyle, onDeleteSelectedElements: deleteSelectedElementsHandler, onDuplicateSelected: handleDuplicateSelected }),
                            React.createElement(Background, { variant: backgroundVariant, gap: backgroundVariant === 'lines' ? 20 : 20, size: 1, color: 'var(--dots-color)', style: { zIndex: 0 } }),
                            React.createElement(MiniMap, { nodeStrokeWidth: 2, nodeBorderRadius: 2, maskColor: 'rgba(255, 0, 102, 0.1)', pannable: true, zoomable: true, style: { width: 180, height: 120 }, position: 'bottom-right' }),
                            React.createElement(RFControls, { showZoom: true, showFitView: true, showInteractive: true, style: { zIndex: 25 } }),
                            React.createElement('div', {className: 'custom-attribution'}, 'Powered by ', React.createElement('a', {href: 'https://xocostudio.com/', target: '_blank'}, 'XocoStudio'), ' | ', React.createElement('a', {href: 'https://xocostudio.com/', target: '_blank'}, 'Xocomon') ),
                            contextMenu && React.createElement('div', { className: 'context-menu', style: { top: contextMenu.top, left: contextMenu.left }, }, React.createElement('button', { onClick: () => toggleNodeLock(contextMenu.id) }, contextMenu.nodeData.locked ? unlockIconSVG : lockIconSVG, contextMenu.nodeData.locked ? 'Desbloquear Nodo' : 'Bloquear Nodo' ) )
                        )
                    )
                );
            };

            const AppContainer = () => React.createElement('div', { className: 'flow-app-container' }, React.createElement(ReactFlowProvider, null, React.createElement(FlowApp)));
            ReactDOM.render(React.createElement(AppContainer), document.getElementById('app-container'));
        }
    </script>
</body>
</html>